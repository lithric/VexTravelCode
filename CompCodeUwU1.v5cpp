{"mode":"Text","textContent":"// ----------------------------------------------------------------------------\n//                                                                            \n//    Project:                                               \n//    Author:\n//    Created:\n//    Configuration:        \n//                                                                            \n// ----------------------------------------------------------------------------\n\n// Include the V5 Library\n#include \"vex.h\"\n#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <string>\n#include <tgmath.h>\n#include <thread>\n#include <vector>\n#include <map>\n\n// define some useful changes\n#define printB(a) Brain.Screen.print(a);Brain.Screen.newLine()\n#define The\n#define Then wait(act.localTime * 2.4,seconds)\n#define And ;\n#define Go\n#define To\n#define _USE_MATH_DEFINES\n#define ForwardFor(a) spinFor(forward,(2*a/wheelDiam)*180/M_PI,degrees, false);localTime = a*100/globalVelocity\n#define ReverseFor(a) spinFor(reverse,(2*a/wheelDiam)*180/M_PI,degrees, false);localTime = a*100/globalVelocity\n#define placeStr(s) #s\n#define str(s) placeStr(s)\n#define anon(EXP) []() -> void{EXP;}\n#define motorOpp(OPP,IEnumerableGroup) for (int i=0; i<sizeof(IEnumerableGroup); i++) {(*IEnumerableGroup[i]).OPP;}\n#define __drive(a) {\"drive\", std::vector<double>(a)}\n#define __speed(a) {\"speed\", std::vector<double>(a)}\n#define __turn(a) {\"turn\", std::vector<double>(a)}\n#define __strafe(a) {\"strafe\", std::vector<double>(a)}\n\n\n// Allows for easier use of the VEX Library\nusing namespace vex;\n\n// assign global variables\n    double rampThreshold = 20; // 20deg\n    bool debugMode = false;\n    bool single = false;\n    int debugVal = 0;\n    double MaxMotorSpeed = 200; // 200rpm\n    double globalVelocity = 200; // 200rpm\n    double globalAcceleration = 60; // 60cm/s^2\n    double wheelDiam = 10.16;\n    double localTime = 0.00;\n    double botDiam = 39;\n    std::vector<vex::motor*> IMotor = {&Left,&Right,&Middle,&Arm,&Wrist,&Pitchfork1};\n// Begin project code\n\nvoid preAutonomous(void) {\n  // actions to do when the program starts\n  Brain.Screen.clearScreen();\n  Brain.Screen.print(\"pre auton code\");\n  wait(1, seconds);\n}\n\nclass Custom {\n    public:\n    int globalPercVel = 0; // 0% of 200\n    double wheelDiam = 10.16; // 10.16cm -> 4in\n    double localTime = 0.00; // 0.00s\n    double botDiam = 39; // 39cm\n    void SetGlobalVelocity(int vel = -1,std::string option = \"percent\") {\n        if (vel < 0) {\n            vel = globalPercVel;\n        }\n        (*IMotor[0]).setVelocity(vel,percent);\n        (*IMotor[1]).setVelocity(vel,percent);\n        (*IMotor[2]).setVelocity(vel,percent);\n        globalVelocity = (wheelDiam*M_PI*vel/100)*MaxMotorSpeed;\n    }\n    void ResetAllMotors(std::string option = \"continue\") {\n        if (option == \"stop\") {\n            Left.stop();\n            Right.stop();\n            Middle.stop();\n            Arm.stop();\n            Wrist.stop();\n            Pitchfork1.spin(reverse);\n        }\n        if (option == \"hold\") {\n            Left.stop(hold);\n            Right.stop(hold);\n            Middle.stop(hold);\n            Arm.stop(hold);\n            Wrist.stop(hold);\n            Pitchfork1.spin(reverse);\n        }\n        Left.setPosition(0,degrees);\n        Right.setPosition(0,degrees);\n        Middle.setPosition(0,degrees);\n    } // the \"stop\" option resets all the motors and stops them too.\n\n    void Drive(double d) {\n        if (d > 0) {\n            Left.ForwardFor(d);\n            Right.ForwardFor(d);\n        }\n        if (d < 0) {\n            Left.ReverseFor(-d);\n            Right.ReverseFor(-d);\n        }\n    }\n\n    void Strafe(double d) {\n        if (d > 0) {\n            Middle.ForwardFor(d);\n        }\n        if (d < 0) {\n            Middle.ReverseFor(-d);\n        }\n    }\n\n    // \"when started\" hat block\n    int whenStarted1() {\n        SetGlobalVelocity(globalPercVel);\n        return 0;\n    }\n\n    void Turn(double deg) {\n        double botCirc = botDiam * M_PI;\n        double perc = std::abs(deg/360);\n        double d = perc * botCirc;\n        if (deg > 0) {\n            Left.ForwardFor(d);\n            Right.ReverseFor(d);\n        }\n        else if (deg < 0) {\n            Left.ReverseFor(d);\n            Right.ForwardFor(d);\n        }\n    }\n\n    void GradualStop(std::string option) {\n        int i = globalPercVel;\n        if (option == \"forward\") {\n            while (i >= 1) {\n                    i = i-1;\n                    SetGlobalVelocity(i);\n                    Left.spin(forward);\n                    Right.spin(forward);\n                    wait(2/globalAcceleration,seconds);\n                    globalPercVel = i;\n                }\n            Left.stop();\n            Right.stop();\n            Left.setPosition(0,degrees);\n            Right.setPosition(0,degrees);\n        }\n        else if (option == \"back\") {\n            while (i >= 1) {\n                    i = i-1;\n                    SetGlobalVelocity(i);\n                    Left.spin(reverse);\n                    Right.spin(reverse);\n                    wait(2/globalAcceleration,seconds);\n                    globalPercVel = i;\n                }\n            Left.stop();\n            Right.stop();\n            Left.setPosition(0,degrees);\n            Right.setPosition(0,degrees);\n        }\n        else if (option == \"right\") {\n            while (i >= 1) {\n                    i = i-1;\n                    SetGlobalVelocity(i);\n                    Middle.spin(forward);\n                    wait(2/globalAcceleration,seconds);\n                    globalPercVel = i;\n                }\n            Middle.stop();\n            Middle.setPosition(0,degrees);\n        }\n        else if (option == \"left\") {\n            while (i >= 1) {\n                    i = i-1;\n                    SetGlobalVelocity(i);\n                    Middle.spin(reverse);\n                    wait(2/globalAcceleration,seconds);\n                    globalPercVel = i;\n                }\n            Middle.stop();\n            Middle.setPosition(0,degrees);\n        }\n        else if (option == \"clockwise\") {\n            while (i >= 1) {\n                    i = i-1;\n                    SetGlobalVelocity(i);\n                    Left.spin(forward);\n                    Right.spin(reverse);\n                    wait(2/globalAcceleration,seconds);\n                    globalPercVel = i;\n                }\n            Left.stop();\n            Right.stop();\n            Left.setPosition(0,degrees);\n            Right.setPosition(0,degrees);\n        }\n        else if (option == \"anti-clockwise\") {\n            while (i >= 1) {\n                    i = i-1;\n                    SetGlobalVelocity(i);\n                    Left.spin(reverse);\n                    Right.spin(forward);\n                    wait(2/globalAcceleration,seconds);\n                    globalPercVel = i;\n                }\n            Left.stop();\n            Right.stop();\n            Left.setPosition(0,degrees);\n            Right.setPosition(0,degrees);\n        }\n    } // options: forward, back, right, left\n\n    void GradualForward(int vel,double dist = 0,bool empty = true) {\n        Left.setPosition(0,degrees);\n        Right.setPosition(0,degrees);\n        SetGlobalVelocity(1);\n        int i = 1;\n        double degr = (2*dist/wheelDiam)*180/M_PI;\n        double accelDist = (vel-1)*(vel-1)/globalAcceleration;\n        double accelDegr = (2*accelDist/wheelDiam)*180/M_PI;\n        Brain.Screen.print(degr);\n        Brain.Screen.print(\"   \");\n        Brain.Screen.print(accelDegr);\n        while(i < vel && Left.rotation(deg)+Right.rotation(deg) < degr*2) {\n            SetGlobalVelocity(i);\n            i++;\n            Left.spin(forward);\n            Right.spin(forward);\n            wait(2/globalAcceleration,seconds);\n            globalPercVel = i;\n        }\n        Left.setPosition(0,degrees);\n        Right.setPosition(0,degrees);\n        if (empty) {\n            while(Left.rotation(deg)+Right.rotation(deg) < degr*2) {\n                wait(0.01,seconds);\n            }\n            GradualStop(\"forward\");\n        }\n    }\n\n    void GradualBack(int vel,double dist = 0,bool empty = true) {\n        Left.setPosition(0,degrees);\n        Right.setPosition(0,degrees);\n        SetGlobalVelocity(1);\n        int i = 1;\n        double degr = (2*dist/wheelDiam)*180/M_PI;\n        while(i < vel && -Left.rotation(deg)-Right.rotation(deg) < degr*2) {\n            SetGlobalVelocity(i);\n            i++;\n            Left.spin(reverse);\n            Right.spin(reverse);\n            wait(2/globalAcceleration,seconds);\n            globalPercVel = i;\n        }\n        Left.setPosition(0,degrees);\n        Right.setPosition(0,degrees);\n        if (empty) {\n            while(-Left.rotation(deg)-Right.rotation(deg) < degr*2) {\n                wait(0.01,seconds);\n            }\n            GradualStop(\"back\");\n        }\n    }\n\n    void GradualRight(int vel,double dist = 0,bool empty = true) {\n        Middle.setPosition(0,degrees);\n        SetGlobalVelocity(1);\n        int i = 1;\n        double degr = (2*dist/wheelDiam)*180/M_PI;\n        while(i < vel && Middle.rotation(deg) < degr*2) {\n            SetGlobalVelocity(i);\n            i++;\n            Middle.spin(forward);\n            wait(2/globalAcceleration,seconds);\n            globalPercVel = i;\n        }\n        Middle.setPosition(0,degrees);\n        if (empty) {\n            while(Middle.rotation(deg) < degr*2) {\n                wait(0.01,seconds);\n            }\n            GradualStop(\"right\");\n        }\n    }\n\n    void GradualLeft(int vel,double dist = 0,bool empty = true) {\n        Middle.setPosition(0,degrees);\n        SetGlobalVelocity(1);\n        int i = 1;\n        double degr = (2*dist/wheelDiam)*180/M_PI;\n        while(i < vel && -Middle.rotation(deg) < degr*2) {\n            SetGlobalVelocity(i);\n            i++;\n            Middle.spin(reverse);\n            wait(2/globalAcceleration,seconds);\n            globalPercVel = i;\n        }\n        Middle.setPosition(0,degrees);\n        if (empty) {\n            while(-Middle.rotation(deg) < degr*2) {\n                wait(0.01,seconds);\n            }\n            GradualStop(\"left\");\n        }\n    }\n\n    void GradualTurn(int vel, double degre = 0, bool empty = true) {\n        double botCirc = botDiam * M_PI;\n        double perc = std::abs(degre/360);\n        // how to determine the distance needed to rotate a certrain amount of degrees\n        double dist = perc * botCirc;\n        if (vel > 0) {\n            Left.setPosition(0,degrees);\n            Right.setPosition(0,degrees);\n            SetGlobalVelocity(1);\n            int i = 1;\n            double degr = (dist/wheelDiam)*180/M_PI;\n            while(i < vel && Left.rotation(deg)-Right.rotation(deg) < degr*2) {\n                SetGlobalVelocity(i);\n                i++;\n                Left.spin(forward);\n                Right.spin(reverse);\n                wait(2/globalAcceleration,seconds);\n                globalPercVel = i;\n            }\n            Left.setPosition(0,degrees);\n            Right.setPosition(0,degrees);\n            if (empty) {\n                while(Left.rotation(deg)-Right.rotation(deg) < degr*2) {\n                    wait(0.01,seconds);\n                }\n                Left.stop();\n                Right.stop();\n                //GradualStop(\"clockwise\");\n            }\n        }\n        else if (vel < 0) {\n            Left.setPosition(0,degrees);\n            Right.setPosition(0,degrees);\n            SetGlobalVelocity(1);\n            int i = 1;\n            double degr = (2*dist/wheelDiam)*180/M_PI;\n            while(i < vel && -Left.rotation(deg)+Right.rotation(deg) < degr*2) {\n                SetGlobalVelocity(i);\n                i++;\n                Left.spin(reverse);\n                Right.spin(forward);\n                wait(2/globalAcceleration,seconds);\n                globalPercVel = i;\n            }\n            Left.setPosition(0,degrees);\n            Right.setPosition(0,degrees);\n            if (empty) {\n                while(-Left.rotation(deg)+Right.rotation(deg) < degr*2) {\n                    wait(0.01,seconds);\n                }\n                GradualStop(\"anti-clockwise\");\n            }\n        }\n    }\n    void stopping() {\n        Left.stop();\n        Right.stop();\n    }\n};\n\nclass DriveInstructions {\n    public:\n    std::map<std::string,std::vector<double>> instructions;\n    void start() {\n        for (auto const& instruct : instructions) {\n            auto key = instruct.first;\n            auto val = instruct.second;\n            char bank[6];\n            for (int i=0; i<key.length(); i++) {\n                bank[i] = key[i];\n            }\n            Brain.Screen.print(bank);\n            if (key == \"speed\") {\n                (*IMotor[0]).setVelocity(val[0],percent);\n                for(int i=0; i<sizeof(IMotor); i++) {\n                    (*IMotor[i]).setVelocity(val[0],percent);\n                }\n            }\n            else if (key == \"drive\") {\n                if (val[0] > 0) {\n                    Left.ForwardFor(val[0]);\n                    Right.ForwardFor(val[0]);\n                }\n                if (val[0] < 0) {\n                    Left.ReverseFor(-val[0]);\n                    Right.ReverseFor(-val[0]);\n                }\n            }\n            else if (key == \"turn\") {\n                double botCirc = botDiam * M_PI;\n                double perc = std::abs(val[0]/360);\n                double d = perc * botCirc;\n                if (val[0] > 0) {\n                    Left.ForwardFor(d);\n                    Right.ReverseFor(d);\n                }\n                else if (val[0] < 0) {\n                    Left.ReverseFor(d);\n                    Right.ForwardFor(d);\n                }\n            }\n            else if (key == \"strafe\") {\n                if (val[0] > 0) {\n                    Middle.ForwardFor(val[0]);\n                }\n                if (val[0] < 0) {\n                    Middle.ReverseFor(-val[0]);\n                }\n            }\n        }\n    }\n};\nvoid autonomous(void) {\n  Brain.Screen.clearScreen();\n  Brain.Screen.print(\"autonomous code\");\n\n\n\nint Brain_precision = 0, Console_precision = 0;\n    Custom act; // initializes the act object for movement actions\n    DriveInstructions beginning;\n    beginning.instructions = {\n      __speed(100),\n      __drive(20)\n    };\n    //beginning.start();\n    // act.localtime contains the time for an operation to execute\n    // reset all motors completely\n    act.ResetAllMotors(\"stop\");\n    // reset all motors completely\n  act.botDiam = 39;\n  act.wheelDiam = 10.16;\n  act.globalPercVel = 50;\n  globalAcceleration = 60;\n  act.SetGlobalVelocity();\n  //di = 20cm\n  //circ = di*pi\n  //d = (deg*pi/180)*di/2\n  //if di is measured in centimeters\n  //d will be in centimeters as a result\n  //rpm\n  //centimeters\n  //tape width = 2cm\n  //large tile = 62cm\n  //small tile = 58cm\n  //med tile = 60cm\n  //to tape = 116cm\n  //tape gap = 2cm\n  // velocity per degree\n  // distance per velocity\n  // what is the distance traveled when stopping at each level of velocity\n  // a = (v_f-v_i)/t\n  // t = (v_f-v_i)/a\n  // d = t(v_f-v_i)\n  // t = d/(v_f-v_i)\n  // (v_f-v_i)/a = d/(v_f-v_i)\n  // (v_f-v_i)**2/a = d\n  /*\n  int i = 100;\n  while(i--) {\n      printB(Enert.orientation(roll,degrees));\n      wait(0.1,seconds);\n  }\n  */\n  //Brain.Timer.event(act.stopping(),15000);\n  Arm.spinFor(forward,475,degrees);\n  Wrist.spinFor(forward,41,degrees);\n  act.SetGlobalVelocity(100);\n  wait(1,seconds);\n  act.Drive(16);\n  Then;\n  act.Turn(90);\n  Then;\n  act.Strafe(20);\n  Then;\n  act.Strafe(-2);\n  Then;\n  act.Drive(38);\n  wait(1,seconds);\n  Then;\n  Pitchfork1.spinFor(forward,50,degrees);\n  Then;\n  /*\n  act.SetGlobalVelocity(100);\n  act.Drive(70);\n  Then;\n  act.SetGlobalVelocity(50);\n  while(std::abs(Enert.orientation(roll,degrees)) > rampThreshold) {\n      Left.spin(forward);\n      Right.spin(forward);\n      wait(0.1,seconds);\n  }\n  act.ResetAllMotors(\"hold\");\n  act.SetGlobalVelocity(100);\n  Then;\n  */\n  /*\n  act.GradualForward(60,10);\n  act.GradualRight(60,10);\n  act.Turn(90);\n  Then;\n  act.GradualForward(60,10);\n  */\n  \n  //t = ((d-2*pow(v_f-v_i,2)/globalAcceleration)/v_f)+2*((v_f-v_i)/globalAcceleration);\n  //wait(t,seconds);\n  // dynamic motor command structure\n  //motor(50,100),motor(100,20) => motor(150,120)\n  /*\n  DriveInstructions beginning;\n  DriveInstructions goUpRamp;\n  DriveInstructions pickUpGoal;\n  beginning.instructions = {\n      speed(100),\n      drive(20),\n      turn(20),\n      turn(-20),\n      drive(40)\n  };\n  beginning.start();\n  */\n}\n\nvoid userControl(void) {\n  Brain.Screen.clearScreen();\n  // place driver control in this while loop\n  while (true) {\n    wait(20, msec);\n    while(true) {\n      //Controller1.ButtonY.pressed([]()->void{debugMode=!debugMode;debugMode? []()->void{printB(\"Debug Mode On\");}:[]()->void{printB(\"Debug Mode Off\");};}); // toggle debug mode\n      Controller1.ButtonY.pressed( anon(single=true) );\n      Controller1.ButtonY.released( anon(if(single){printB(debugMode ? \"Debug Mode OFF\":\"Debug Mode ON\");debugMode = !debugMode;single=false;}));\n      //Controller1.ButtonY.released( anon(debugMode = !debugMode; printB(debugMode ? \"Debug Mode ON\":\"Debug Mode OFF\")) );\n      //debug\n          Controller1.ButtonL1.pressed( anon(single=true) );\n      //debug\n      if (debugMode) {\n          Controller1.ButtonX.pressed( anon(Brain.Screen.print(\"hello\")) );\n          if (!Controller1.ButtonL1.pressing()) {\n              single=true;\n          }\n          else if (single) {\n              rampThreshold -= 0.5;\n              Brain.Screen.print(\"rampThreshold\");\n              printB(rampThreshold);\n              single=false;\n              wait(0.3,seconds);\n          }\n          if (!Controller1.ButtonL2.pressing()) {\n              single=true;\n          }\n          else if (single) {\n              rampThreshold += 0.5;\n              Brain.Screen.print(\"rampThreshold\");\n              printB(rampThreshold);\n              single = false;\n              wait(0.3,seconds);\n          }\n      }\n      else {\n        //drive wheels\n        Left.spin(vex::directionType::fwd, Controller1.Axis3.value(), vex::velocityUnits::pct);\n        Right.spin(vex::directionType::fwd, Controller1.Axis2.value(), vex::velocityUnits::pct);\n        Middle.spin(vex::directionType::fwd, Controller1.Axis4.value(), vex::velocityUnits::pct);\n        //Arm\n        //Raise arm\n            if(Controller1.ButtonL1.pressing()) {\n                Arm.spin(directionType::fwd);\n            }\n                //lower arm\n            else if(Controller1.ButtonL2.pressing()) {\n                Arm.spin(directionType::rev);\n            }\n                //hold arm\n            else {\n                Arm.stop(hold);\n            }\n\n            Controller1.ButtonUp.pressed( anon(StickyPiston = !StickyPiston) );\n            //StickyPiston.set(Controller1.ButtonUp.pressing() ? true:false);\n\n            //wrist\n                //raise wrist\n            if(Controller1.ButtonR1.pressing()) {\n                Wrist.spin(directionType::fwd);\n            }\n                //lower wrist\n            else if(Controller1.ButtonR2.pressing()) {\n                Wrist.spin(directionType::rev);\n            }\n                //hold wrist\n            else {\n                Wrist.stop(hold);\n            }\n\n\n            //Pitchfork1\n                //Open\n            if (Controller1.ButtonA.pressing()) {\n                Pitchfork1.spin(directionType::fwd);\n            }\n                //Close\n            else if(Controller1.ButtonB.pressing()) {\n                Pitchfork1.spin(directionType::rev);\n            }\n                //hold claw\n            else {\n                Pitchfork1.stop(hold);\n            }\n        }\n    }\n  }\n}\n\nint main() {\n  // create competition instance\n  competition Competition;\n\n  // Set up callbacks for autonomous and driver control periods.\n  Competition.autonomous(autonomous);\n  Competition.drivercontrol(userControl);\n\n  // Run the pre-autonomous function.\n  preAutonomous();\n\n  // Prevent main from exiting with an infinite loop.\n  while (true) {\n    wait(100, msec);\n  }\n}","textLanguage":"cpp","rconfig":[{"port":[8],"name":"Arm","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[9],"name":"Wrist","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio36_1"},"triportSourcePort":22},{"port":[10],"name":"Pitchfork1","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio36_1"},"triportSourcePort":22},{"port":[],"name":"Controller1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[6],"name":"Enert","customName":true,"deviceType":"Inertial","deviceClass":"inertial","setting":{"id":"partner"},"triportSourcePort":22},{"port":[1],"name":"StickyPiston","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":22},{"port":[1],"name":"Left","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"}},{"port":[2],"name":"Right","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"}},{"port":[3],"name":"Middle","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"}}],"slot":0,"platform":"V5","sdkVersion":"20210708.10.00.00","appVersion":"2.2.0","fileFormat":"1.0.1","icon":"","targetBrainGen":"First","target":"Physical"}